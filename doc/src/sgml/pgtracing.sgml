<!-- doc/src/sgml/pgtracing.sgml -->

<sect1 id="pgtracing" xreflabel="pg_tracing">
 <title>pg_tracing &mdash; generate server-side spans for distributed tracing</title>

 <indexterm zone="pgtracing">
  <primary>pg_tracing</primary>
 </indexterm>

 <para>
  The <filename>pg_tracing</filename> module provides a means to
  generate server-side spans for distributed tracing.
 </para>

 <para>
  The module must be loaded by adding <literal>pg_tracing</literal> to
  <xref linkend="guc-shared-preload-libraries"/> in
  <filename>postgresql.conf</filename>, because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
  In addition, query identifier calculation must be enabled in order for the
  module to be active, which is done automatically if <xref linkend="guc-compute-query-id"/>
  is set to <literal>auto</literal> or <literal>on</literal>, or any third-party
  module that calculates query identifiers is loaded.
 </para>

 <para>
   When <filename>pg_tracing</filename> is active, it generates spans
   on sampled queries. To access these spans, the module provides two views:
   <structname>pg_tracing_consume_spans</structname> and
   <structname>pg_tracing_peek_spans</structname>.
   The utility functions <function>pg_tracing_reset</function> and
   <function>pg_tracing_info</function> provides ways to read and reset
   module's statistics. These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_tracing</command>.
 </para>

 <sect2 id="pgtracing-pg-tracing-consume-spans">
  <title>The <structname>pg_tracing_consume_spans</structname> View</title>

  <para>
   The spans generated by the module are made available via a
   view named <structname>pg_tracing_consume_spans</structname>.  This view
   contains one row for each generated span.
   The columns of the view are shown in
   <xref linkend="pgtracing-consume-spans-columns"/>.
  </para>

  <table id="pgtracing-consume-spans-columns">
   <title><structname>pg_tracing_consume_spans</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>traceid</structfield> <type>bigint</type>
      </para>
      <para>
       Trace identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parent_id</structfield> <type>bigint</type>
      </para>
      <para>
       Identifier of the span's parent
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_id</structfield> <type>bigint</type>
      </para>
      <para>
       Identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>queryid</structfield> <type>bigint</type>
      </para>
      <para>
       Hash code to identify identical normalized queries
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       Name of the span. For non-node spans, this can be: Parse, Post Parse, Planner, Executor.
       For span generated from execution plan, it will use the node type: Select, Insert, SeqScan, Gather...
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>resource</structfield> <type>text</type>
      </para>
      <para>
       Name of the span's operation. For Executor, it can be Start, Run, Finish and End.
       Top spans will have the normalised query text.
       Node spans will have the detailed node like 'SeqScan on pgbench_branches a'
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Start time of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_start_ns</structfield> <type>smallint</type>
      </para>
      <para>
       Nanoseconds part of start time. Timestamp only provides a microsecond precision
       and spans need nanosecond precision
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>duration</structfield> <type>bigint</type>
      </para>
      <para>
       Duration of the span in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>duration</structfield> <type>bigint</type>
      </para>
      <para>
       Duration of the span in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_error_code</structfield> <type>bpchar</type>
      </para>
      <para>
       Error code of the query. 00000 for a succesful query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Pid of the backend process processing the query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>nested_level</structfield> <type>smallint</type>
      </para>
      <para>
       Nested level of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subxact_count</structfield> <type>smallint</type>
      </para>
      <para>
       Active count of backend's subtransaction when the span was created
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>top_span</structfield> <type>boolean</type>
      </para>
      <para>
       True if the span is a top span for its nested level
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_startup_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated cost before fetching any tuples by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_total_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated total cost by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_rows</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated number of row plan is expected to emit
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_width</structfield> <type>integer</type>
      </para>
      <para>
       Estimated row width in bytes by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>rows</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples processed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>nloops</structfield> <type>bigint</type>
      </para>
      <para>
       Number of cycles for this node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent reading blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent writing blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent reading temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent writing temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL records generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL full page images generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Total amount of WAL generated by the node in bytes
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_functions</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of functions JIT-compiled by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_generation_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on generating JIT code, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_inlining_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on inlining functions, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_optimization_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on optimizing, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>startup</structfield> <type>bigint</type>
      </para>
      <para>
       Time to the first tuple in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameters</structfield> <type>text</type>
      </para>
      <para>
       Value of the query's parameters
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="pgtracing-pg-stat-statements-info">
  <title>The <structname>pg_stat_statements_info</structname> View</title>

  <indexterm>
   <primary>pg_stat_statements_info</primary>
  </indexterm>

  <para>
   The statistics of the <filename>pg_tracing</filename> module
   itself are tracked and made available via a view named
   <structname>pg_stat_statements_info</structname>.  This view contains
   only a single row.  The columns of the view are shown in
   <xref linkend="pgtracinginfo-columns"/>.
  </para>

  <table id="pgtracinginfo-columns">
   <title><structname>pg_stat_statements_info</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dealloc</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of times <structname>pg_tracing</structname>
       entries about the least-executed statements were deallocated
       because more distinct statements than
       <varname>pg_tracing.max</varname> were observed
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which all statistics in the
       <structname>pg_tracing</structname> view were last reset.
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="pgtracing-funcs">
  <title>Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pg_stat_statements_reset(userid Oid, dbid Oid, queryid bigint) returns void</function>
     <indexterm>
      <primary>pg_stat_statements_reset</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>pg_stat_statements_reset</function> discards statistics
      gathered so far by <filename>pg_tracing</filename> corresponding
      to the specified <structfield>userid</structfield>, <structfield>dbid</structfield>
      and <structfield>queryid</structfield>.  If any of the parameters are not
      specified, the default value <literal>0</literal>(invalid) is used for
      each of them and the statistics that match with other parameters will be
      reset.  If no parameter is specified or all the specified parameters are
      <literal>0</literal>(invalid), it will discard all statistics.
      If all statistics in the <filename>pg_tracing</filename>
      view are discarded, it will also reset the statistics in the
      <structname>pg_stat_statements_info</structname> view.
      By default, this function can only be executed by superusers.
      Access may be granted to others using <command>GRANT</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_tracing(showtext boolean) returns setof record</function>
     <indexterm>
      <primary>pg_tracing</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
     <para>
      The <structname>pg_tracing</structname> view is defined in
      terms of a function also named <function>pg_tracing</function>.
      It is possible for clients to call
      the <function>pg_tracing</function> function directly, and by
      specifying <literal>showtext := false</literal> have query text be
      omitted (that is, the <literal>OUT</literal> argument that corresponds
      to the view's <structfield>query</structfield> column will return nulls).  This
      feature is intended to support external tools that might wish to avoid
      the overhead of repeatedly retrieving query texts of indeterminate
      length.  Such tools can instead cache the first query text observed
      for each entry themselves, since that is
      all <filename>pg_tracing</filename> itself does, and then retrieve
      query texts only as needed.  Since the server stores query texts in a
      file, this approach may reduce physical I/O for repeated examination
      of the <structname>pg_tracing</structname> data.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="pgtracing-config-params">
  <title>Configuration Parameters</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_tracing.max</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max</varname> is the maximum number of
      statements tracked by the module (i.e., the maximum number of rows
      in the <structname>pg_tracing</structname> view).  If more distinct
      statements than that are observed, information about the least-executed
      statements is discarded.  The number of times such information was
      discarded can be seen in the
      <structname>pg_stat_statements_info</structname> view.
      The default value is 5000.
      This parameter can only be set at server start.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track</varname> (<type>enum</type>)
     <indexterm>
      <primary><varname>pg_tracing.track</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track</varname> controls which statements
      are counted by the module.
      Specify <literal>top</literal> to track top-level statements (those issued
      directly by clients), <literal>all</literal> to also track nested statements
      (such as statements invoked within functions), or <literal>none</literal> to
      disable statement statistics collection.
      The default value is <literal>top</literal>.
      Only superusers can change this setting.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track_utility</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.track_utility</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track_utility</varname> controls whether
      utility commands are tracked by the module.  Utility commands are
      all those other than <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>, and <command>MERGE</command>.
      The default value is <literal>on</literal>.
      Only superusers can change this setting.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track_planning</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.track_planning</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track_planning</varname> controls whether
      planning operations and duration are tracked by the module.
      Enabling this parameter may incur a noticeable performance penalty,
      especially when statements with identical query structure are executed
      by many concurrent connections which compete to update a small number of
      <structname>pg_tracing</structname> entries.
      The default value is <literal>off</literal>.
      Only superusers can change this setting.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.save</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.save</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.save</varname> specifies whether to
      save statement statistics across server shutdowns.
      If it is <literal>off</literal> then statistics are not saved at
      shutdown nor reloaded at server start.
      The default value is <literal>on</literal>.
      This parameter can only be set in the <filename>postgresql.conf</filename>
      file or on the server command line.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   The module requires additional shared memory proportional to
   <varname>pg_tracing.max</varname>.  Note that this
   memory is consumed whenever the module is loaded, even if
   <varname>pg_tracing.track</varname> is set to <literal>none</literal>.
  </para>

  <para>
   These parameters must be set in <filename>postgresql.conf</filename>.
   Typical usage might be:

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_tracing'

compute_query_id = on
pg_tracing.max = 10000
pg_tracing.track = all
</programlisting>
  </para>
 </sect2>

 <sect2 id="pgtracing-sample-output">
  <title>Sample Output</title>

<screen>
bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_tracing ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------&zwsp;------------------
query           | UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2
calls           | 3000
total_exec_time | 25565.855387
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 2 ]---+--------------------------------------------------&zwsp;------------------
query           | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2
calls           | 3000
total_exec_time | 20756.669379
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 3 ]---+--------------------------------------------------&zwsp;------------------
query           | copy pgbench_accounts from stdin
calls           | 1
total_exec_time | 291.865911
rows            | 100000
hit_percent     | 100.0000000000000000
-[ RECORD 4 ]---+--------------------------------------------------&zwsp;------------------
query           | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2
calls           | 3000
total_exec_time | 271.232977
rows            | 3000
hit_percent     | 98.8454011741682975
-[ RECORD 5 ]---+--------------------------------------------------&zwsp;------------------
query           | alter table pgbench_accounts add primary key (aid)
calls           | 1
total_exec_time | 160.588563
rows            | 0
hit_percent     | 100.0000000000000000


bench=# SELECT pg_stat_statements_reset(0,0,s.queryid) FROM pg_tracing AS s
            WHERE s.query = 'UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2';

bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_tracing ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------&zwsp;------------------
query           | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2
calls           | 3000
total_exec_time | 20756.669379
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 2 ]---+--------------------------------------------------&zwsp;------------------
query           | copy pgbench_accounts from stdin
calls           | 1
total_exec_time | 291.865911
rows            | 100000
hit_percent     | 100.0000000000000000
-[ RECORD 3 ]---+--------------------------------------------------&zwsp;------------------
query           | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2
calls           | 3000
total_exec_time | 271.232977
rows            | 3000
hit_percent     | 98.8454011741682975
-[ RECORD 4 ]---+--------------------------------------------------&zwsp;------------------
query           | alter table pgbench_accounts add primary key (aid)
calls           | 1
total_exec_time | 160.588563
rows            | 0
hit_percent     | 100.0000000000000000
-[ RECORD 5 ]---+--------------------------------------------------&zwsp;------------------
query           | vacuum analyze pgbench_accounts
calls           | 1
total_exec_time | 136.448116
rows            | 0
hit_percent     | 99.9201915403032721

bench=# SELECT pg_stat_statements_reset(0,0,0);

bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_tracing ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------&zwsp;---------------------------
query           | SELECT pg_stat_statements_reset(0,0,0)
calls           | 1
total_exec_time | 0.189497
rows            | 1
hit_percent     |
-[ RECORD 2 ]---+--------------------------------------------------&zwsp;---------------------------
query           | SELECT query, calls, total_exec_time, rows, $1 * shared_blks_hit /          +
                |                nullif(shared_blks_hit + shared_blks_read, $2) AS hit_percent+
                |           FROM pg_tracing ORDER BY total_exec_time DESC LIMIT $3
calls           | 0
total_exec_time | 0
rows            | 0
hit_percent     |

</screen>
 </sect2>

 <sect2 id="pgtracing-authors">
  <title>Authors</title>

  <para>
   Anthonin Bonnefoy <email>anthonin.bonnefoy@datadoghq.com</email>.
  </para>
 </sect2>

</sect1>
