-- Only trace queries with sample flag
SET pg_tracing.sample_rate = 0.0;
SET pg_tracing.caller_sample_rate = 1.0;
-- Run a simple query
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000001-0000000000000001-01'*/ SELECT 1;
 ?column? 
----------
        1
(1 row)

-- Get top span id
SELECT span_id AS top_span_id from pg_tracing_peek_spans where parent_id='0000000000000001' and span_type!='Parse' \gset
-- Check parameters
SELECT parameters from pg_tracing_peek_spans where span_id=:'top_span_id';
 parameters 
------------
 $1 = 1
(1 row)

-- Check the number of children
SELECT count(*) from pg_tracing_peek_spans where parent_id=:'top_span_id';
 count 
-------
     2
(1 row)

-- Check span_operation
SELECT span_type, span_operation from pg_tracing_peek_spans where trace_id='00000000000000000000000000000001' order by span_start, span_end desc;
  span_type   | span_operation 
--------------+----------------
 Parse        | Parse
 Select query | SELECT $1;
 Planner      | Planner
 Executor     | ExecutorRun
 Result       | Result
(5 rows)

-- Check count of query_id
SELECT count(distinct query_id) from pg_tracing_consume_spans where trace_id='00000000000000000000000000000001';
 count 
-------
     1
(1 row)

-- Check reported number of trace
SELECT traces from pg_tracing_info;
 traces 
--------
     26
(1 row)

-- Trace a statement with function call
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000003-0000000000000003-01'*/ SELECT count(*) from current_database();
 count 
-------
     1
(1 row)

-- Check the generated span span_type, span_operation and order of function call
SELECT span_type, span_operation, lvl FROM peek_ordered_spans where trace_id='00000000000000000000000000000003';
  span_type   |              span_operation              | lvl 
--------------+------------------------------------------+-----
 Parse        | Parse                                    |   1
 Select query | SELECT count(*) from current_database(); |   1
 Planner      | Planner                                  |   2
 Executor     | ExecutorRun                              |   2
 Aggregate    | Aggregate                                |   3
 FunctionScan | FunctionScan on current_database         |   4
(6 rows)

-- Trace a more complex query with multiple function calls
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000004-0000000000000004-01'*/ SELECT s.relation_size + s.index_size
FROM (SELECT
      pg_relation_size(C.oid) as relation_size,
      pg_indexes_size(C.oid) as index_size
    FROM pg_class C) as s limit 1;
 ?column? 
----------
        0
(1 row)

-- Check the nested level of spans for a query with multiple function calls
SELECT span_type, span_operation, lvl FROM peek_ordered_spans where trace_id='00000000000000000000000000000004';
  span_type   |                                                                          span_operation                                                                          | lvl 
--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----
 Parse        | Parse                                                                                                                                                            |   1
 Select query | SELECT s.relation_size + s.index_sizeFROM (SELECT pg_relation_size(C.oid) as relation_size, pg_indexes_size(C.oid) as index_size FROM pg_class C) as s limit $1; |   1
 Planner      | Planner                                                                                                                                                          |   2
 Executor     | ExecutorRun                                                                                                                                                      |   2
 Limit        | Limit                                                                                                                                                            |   3
 SubqueryScan | SubqueryScan on s                                                                                                                                                |   4
 SeqScan      | SeqScan on pg_class c                                                                                                                                            |   5
(7 rows)

-- Check that we're in a correct state after a timeout
set statement_timeout=200;
-- Trace query triggering a statement timeout
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000007-0000000000000007-01'*/ select * from pg_sleep(10);
ERROR:  canceling statement due to statement timeout
SELECT span_type, span_operation, sql_error_code, lvl FROM peek_ordered_spans where trace_id='00000000000000000000000000000007';
  span_type   |       span_operation        | sql_error_code | lvl 
--------------+-----------------------------+----------------+-----
 Parse        | Parse                       | 00000          |   1
 Select query | select * from pg_sleep($1); | 57014          |   1
 Planner      | Planner                     | 00000          |   2
 Executor     | ExecutorRun                 | 57014          |   2
 FunctionScan | FunctionScan on pg_sleep    | 57014          |   3
(5 rows)

-- Cleanup statement setting
set statement_timeout=0;
-- Trace a working query after the timeout to check we're in a consistent state
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000008-0000000000000008-01'*/ select 1;
 ?column? 
----------
        1
(1 row)

-- Check the spans order and error code
SELECT span_type, span_operation, sql_error_code, lvl FROM peek_ordered_spans where trace_id='00000000000000000000000000000008';
  span_type   | span_operation | sql_error_code | lvl 
--------------+----------------+----------------+-----
 Parse        | Parse          | 00000          |   1
 Select query | select $1;     | 00000          |   1
 Planner      | Planner        | 00000          |   2
 Executor     | ExecutorRun    | 00000          |   2
 Result       | Result         | 00000          |   3
(5 rows)

-- Create a prepare statement with trace context passed as the first parameter
PREPARE test_prepared (text, integer) AS /*$1*/ SELECT $2;
EXECUTE test_prepared('dddbs=''postgres.db'',traceparent=''00-00000000000000000000000000000009-0000000000000009-01''', 1);
 ?column? 
----------
        1
(1 row)

SELECT trace_id, span_type, span_operation, parameters, lvl FROM peek_ordered_spans where trace_id='00000000000000000000000000000009';
             trace_id             |  span_type   |                   span_operation                    |                                                   parameters                                                   | lvl 
----------------------------------+--------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-----
 00000000000000000000000000000009 | Select query | PREPARE test_prepared (text, integer) AS SELECT $2; | $1 = 'dddbs=''postgres.db'',traceparent=''00-00000000000000000000000000000009-0000000000000009-01''', $2 = '1' |   1
 00000000000000000000000000000009 | Planner      | Planner                                             |                                                                                                                |   2
 00000000000000000000000000000009 | Executor     | ExecutorRun                                         |                                                                                                                |   2
 00000000000000000000000000000009 | Result       | Result                                              |                                                                                                                |   3
(4 rows)

-- Call the prepared statement with generic plan
SET plan_cache_mode='force_generic_plan';
EXECUTE test_prepared('dddbs=''postgres.db'',traceparent=''00-0000000000000000000000000000000a-000000000000000a-01''', 2);
 ?column? 
----------
        2
(1 row)

SELECT trace_id, span_type, span_operation, parameters, lvl FROM peek_ordered_spans where trace_id='0000000000000000000000000000000a';
             trace_id             |  span_type   |                   span_operation                    | parameters | lvl 
----------------------------------+--------------+-----------------------------------------------------+------------+-----
 0000000000000000000000000000000a | Select query | PREPARE test_prepared (text, integer) AS SELECT $2; |            |   1
 0000000000000000000000000000000a | Executor     | ExecutorRun                                         |            |   2
 0000000000000000000000000000000a | Result       | Result                                              |            |   3
(3 rows)

-- Cleanup
SET plan_cache_mode='auto';
DEALLOCATE test_prepared;
-- Run a statement with node not executed
/*dddbs='postgres.db',traceparent='00-0000000000000000000000000000000b-000000000000000b-01'*/ select 1 limit 0;
 ?column? 
----------
(0 rows)

SELECT span_operation, parameters, lvl from peek_ordered_spans where trace_id='0000000000000000000000000000000b';
   span_operation    |   parameters   | lvl 
---------------------+----------------+-----
 Parse               |                |   1
 select $1 limit $2; | $1 = 1, $2 = 0 |   1
 Planner             |                |   2
 ExecutorRun         |                |   2
 Limit               |                |   3
(5 rows)

-- Test multiple statements in a single query
/*dddbs='postgres.db',traceparent='00-0000000000000000000000000000000c-000000000000000c-01'*/ select 1; select 2;
 ?column? 
----------
        1
(1 row)

 ?column? 
----------
        2
(1 row)

SELECT span_operation, parameters, lvl from peek_ordered_spans where trace_id='0000000000000000000000000000000c';
 span_operation | parameters | lvl 
----------------+------------+-----
 Parse          |            |   1
 select $1;     | $1 = 1     |   1
 Planner        |            |   2
 ExecutorRun    |            |   2
 Result         |            |   3
(5 rows)

-- Check that parameters are not exported when disabled
SET pg_tracing.export_parameters=false;
/*dddbs='postgres.db',traceparent='00-0000000000000000000000000000000d-000000000000000d-01'*/ select 1, 2, 3;
 ?column? | ?column? | ?column? 
----------+----------+----------
        1 |        2 |        3
(1 row)

SELECT span_operation, parameters, lvl from peek_ordered_spans where trace_id='0000000000000000000000000000000d';
   span_operation   | parameters | lvl 
--------------------+------------+-----
 Parse              |            |   1
 select $1, $2, $3; |            |   1
 Planner            |            |   2
 ExecutorRun        |            |   2
 Result             |            |   3
(5 rows)

SET pg_tracing.export_parameters=true;
-- Check generated spans when deparse is disabled
SET pg_tracing.deparse_plan=false;
/*dddbs='postgres.db',traceparent='00-0000000000000000000000000000000e-000000000000000e-01'*/ SELECT * from pg_tracing_test where a=1;
 a | b 
---+---
(0 rows)

SELECT span_operation, deparse_info, parameters, lvl from peek_ordered_spans where trace_id='0000000000000000000000000000000e';
              span_operation               | deparse_info | parameters | lvl 
-------------------------------------------+--------------+------------+-----
 Parse                                     |              |            |   1
 SELECT * from pg_tracing_test where a=$1; |              | $1 = 1     |   1
 Planner                                   |              |            |   2
 ExecutorRun                               |              |            |   2
 BitmapHeapScan on pg_tracing_test         |              |            |   3
 BitmapIndexScan on pg_tracing_index       |              |            |   4
(6 rows)

-- Check generated spans when deparse is enabled
SET pg_tracing.deparse_plan=true;
/*dddbs='postgres.db',traceparent='00-0000000000000000000000000000000f-000000000000000f-01'*/ SELECT * from pg_tracing_test where a=1;
 a | b 
---+---
(0 rows)

SELECT trace_id, span_operation, deparse_info, parameters, lvl from peek_ordered_spans where trace_id='0000000000000000000000000000000f';
             trace_id             |              span_operation               |     deparse_info      | parameters | lvl 
----------------------------------+-------------------------------------------+-----------------------+------------+-----
 0000000000000000000000000000000f | Parse                                     |                       |            |   1
 0000000000000000000000000000000f | SELECT * from pg_tracing_test where a=$1; |                       | $1 = 1     |   1
 0000000000000000000000000000000f | Planner                                   |                       |            |   2
 0000000000000000000000000000000f | ExecutorRun                               |                       |            |   2
 0000000000000000000000000000000f | BitmapHeapScan on pg_tracing_test         | Recheck Cond: (a = 1) |            |   3
 0000000000000000000000000000000f | BitmapIndexScan on pg_tracing_index       | Index Cond: (a = 1)   |            |   4
(6 rows)

-- Check multi statement query
CALL clean_spans();
SET pg_tracing.sample_rate = 1.0;
-- Force a multi-query statement with \;
SELECT 1\; SELECT 1, 2;
 ?column? 
----------
        1
(1 row)

 ?column? | ?column? 
----------+----------
        1 |        2
(1 row)

SELECT span_type, span_operation, parameters, lvl from peek_ordered_spans;
  span_type   | span_operation | parameters | lvl 
--------------+----------------+------------+-----
 Parse        | Parse          |            |   1
 Select query | SELECT $1;     | $1 = 1     |   1
 Planner      | Planner        |            |   2
 Executor     | ExecutorRun    |            |   2
 Result       | Result         |            |   3
(5 rows)

CALL clean_spans();
-- Check standalone trace
SELECT 1;
 ?column? 
----------
        1
(1 row)

-- Make sure we have unique span ids
SELECT count(span_id) from pg_tracing_consume_spans group by span_id;
 count 
-------
     1
     1
     1
     1
     1
(5 rows)

-- Trigger a planner error
SELECT '\xDEADBEEF'::bytea::text::int;
ERROR:  invalid input syntax for type integer: "\xdeadbeef"
-- Check planner error
SELECT span_type, span_operation, parameters, sql_error_code, lvl from peek_ordered_spans;
  span_type   |        span_operation        |    parameters     | sql_error_code | lvl 
--------------+------------------------------+-------------------+----------------+-----
 Parse        | Parse                        |                   | 00000          |   1
 Select query | SELECT $1::bytea::text::int; | $1 = '\xDEADBEEF' | 22P02          |   1
 Planner      | Planner                      |                   | 22P02          |   2
(3 rows)

-- Cleanup
SET pg_tracing.sample_rate = 0.0;
CALL clean_spans();
